/*
 Copyright (c) 2022 ParallelChain Lab

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

use crate::{Transaction, convert_bytes, convert_from};

use borsh::{BorshSerialize, BorshDeserialize};

/// StorageField defines the key format in canonical path for fields in contract storage
#[derive(Clone)]
pub struct StorageField {
    path :Vec<u8>
}

impl StorageField {

    pub fn new() -> Self{
        Self { path: vec![] }
    }

    pub fn add(&self, child :u8) -> Self {
        let mut path = self.path.clone();
        path.push(child);
        Self { path }
    }

    pub fn get_path(&self) -> &[u8] {
        self.path.as_slice()
    }
}

macro_rules! define_primitives {
    ($($t:ty),*) => {
        $(
            impl Storage for $t {
                fn __load_storage(field :&StorageField) -> Self {
                    Self::__get(field)
                }
                fn __save_storage(&self, field :&StorageField) {
                    Self::__set(field, self)
                }
            }
        )*
    };
}
macro_rules! define_generics {
    ($($t:ty),*) => {
        $(
            impl<T> Storage for $t where T: BorshSerialize + BorshDeserialize{
                fn __load_storage(field :&StorageField) -> Self {
                    Self::__get(field)
                }
                fn __save_storage(&self, field :&StorageField) {
                    Self::__set(field, self)
                }
            }
        )*
    };
}

define_primitives!(i8, u8, i16, u16, i32, u32, i64, u64, i128, u128, usize);
define_primitives!(String, bool);
define_generics!(Vec<T>);

/// Storage trait provides functions as wrapper to getter and setter to the key-value storage in world-state.
/// Impl of this trait is generated by macro. To avoid conflict with user function, function names in this trait are prefix with two underscores.
pub trait Storage {
    fn __get<T: BorshDeserialize + Default>(field :&StorageField) -> T{
        let key_name = field.get_path();

        if let Some(data_ws) = Transaction::get(key_name) {
            if let Some(data_converted) = convert_from(&data_ws) {
                let ret: T = data_converted;
                return ret;
            }
        }
        core::default::Default::default()
    }
    fn __set<T: BorshSerialize>(field :&StorageField, data :&T) {
        let key_name = field.get_path();

        let data_bs = convert_bytes(data);
        Transaction::set(key_name, &data_bs);
    }
    /// generic implementation on method load_storage(), which depends on the type of caller
    fn __load_storage_field<T: Storage>(field :&StorageField) -> T {
        T::__load_storage(field)
    }
    /// generic implementation on method save_storage(), which depends on the type of caller
    fn __save_storage_field<T: Storage>(caller :&T, field :&StorageField) {
        caller.__save_storage(field)
    }
    /// the implementation should eventually call get() to obtain data from world-state and assign the value to the fields of struct
    fn __load_storage(field :&StorageField) -> Self;
    /// the implementation should eventually call set() to obtain fields' value of struct and save it to world-state
    fn __save_storage(&self, field :&StorageField);
}